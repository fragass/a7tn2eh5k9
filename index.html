<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Tetris</title>
  <!-- Fonte retrô para UI do jogo -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <!-- Fonte minimalista para o footer -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400&display=swap" rel="stylesheet">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #111;
      color: #fff;
      font-family: system-ui, monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    .game-area { display: flex; gap: 20px; align-items: flex-start; margin-top: 20px; }
    canvas { background: #000; border: 2px solid #444; }

    .side-panel { display: flex; flex-direction: column; align-items: center; }

    .next-box h2 {
      font-size: 14px;
      margin-bottom: 8px;
      letter-spacing: 1px;
      color: #ff4444;
      font-family: 'Press Start 2P', cursive;
    }

    .card {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
      width: 200px;
      font-size: 12px;
      text-align: left;
      font-family: system-ui, monospace;
    }
    .card h3 { margin: 0 0 8px; font-size: 13px; text-align: center; color: #ff4444; font-family: 'Press Start 2P', cursive; }
    .card ul { list-style: none; padding: 0; margin: 0; }
    .card li { margin: 4px 0; }
    .key {
      display: inline-block;
      background: #222;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 2px 6px;
      margin-right: 6px;
      font-size: 11px;
      font-family: system-ui, monospace;
    }

    #scoreboard {
      margin-top: 12px;
      color: #ff4444;
      font-weight: 700;
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
    }

    .controls { margin-top: 16px; display: flex; justify-content: center; }
    .btn {
      padding: 10px 18px;
      font-size: 13px;
      font-weight: 700;
      border: 1px solid #333;
      border-radius: 8px;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: #222;
      color: #eee;
      font-family: 'Press Start 2P', cursive;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.45); }
    #startPauseBtn.start { background: #234; color: #9fddb3; }
    #startPauseBtn.pause { background: #432; color: #ffd27a; }
    #startPauseBtn.resume { background: #223c55; color: #9fc3ff; }

    #overlayPopup {
      display: flex;
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.88);
      color: #fff;
      z-index: 999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      font-family: 'Press Start 2P', cursive;
    }
    #overlayPopup h2 { font-size: 28px; margin: 0 0 10px; color: #ff4444; letter-spacing: 2px; }
    #overlayInfo { margin: 0 0 16px; font-size: 16px; color: #9fddb3; }
    #overlayBtn { padding: 10px 20px; font-size: 14px; font-weight: 700; }

    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      text-align: center;
      padding: 8px 0;
      font-size: 12px;
      color: #fff;
      background: transparent;
      font-family: 'Inter', Arial, sans-serif; /* fonte minimalista */
    }
  </style>
</head>
<body>
  <div class="game-area">
    <canvas id="tetris" width="200" height="400"></canvas>
    <div class="side-panel">
      <div class="next-box">
        <h2>PRÓXIMA PEÇA</h2>
        <canvas id="next" width="100" height="100"></canvas>
      </div>

      <div class="card">
        <h3>COMANDOS</h3>
        <ul>
          <li><span class="key">←</span><span class="key">→</span> mover</li>
          <li><span class="key">↓</span> acelerar</li>
          <li><span class="key">↑</span> rotacionar</li>
          <li><span class="key">SPACE</span> queda instantânea</li>
          <li><span class="key">C</span> trocar peça (hold)</li>
          <li><span class="key">P</span> iniciar/pausar</li>
          <li><span class="key">R</span> reiniciar</li>
        </ul>
      </div>
    </div>
  </div>

  <div id="scoreboard">Score: 0 | Linhas: 0 | Level: 1</div>
  <div class="controls">
    <button id="startPauseBtn" class="btn start">Iniciar</button>
  </div>

  <div id="overlayPopup">
    <h2 id="overlayTitle">TETRIS</h2>
    <p id="overlayInfo"></p>
    <button id="overlayBtn" class="btn">Iniciar</button>
  </div>

  <audio id="lineClearSound" src="line-clear.wav" preload="auto"></audio>

  <footer>© boni</footer>

  <script>
    // Canvas principal
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    context.scale(20, 20);

    // Canvas da próxima peça
    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');
    nextCtx.scale(20, 20);

    // UI
    const startPauseBtn = document.getElementById('startPauseBtn');
    const overlay = document.getElementById('overlayPopup');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayInfo = document.getElementById('overlayInfo');
    const overlayBtn = document.getElementById('overlayBtn');
    const lineClearSound = document.getElementById('lineClearSound');

    // Estado
    const arena = createMatrix(10, 20);
    const colors = [null,'#00ffff','#ffff00','#800080','#00ff00','#ff0000','#0000ff','#ffa500'];
    const player = { pos:{x:0,y:0}, matrix:null, score:0, next:null, hold:null, canHold:true, lines:0, level:1 };

    let dropCounter = 0, dropInterval = 1000, lastTime = 0;
    let started = false, paused = false, gameOver = false;

    // Bag randomizer
    let pieceBag = [];
    function refillBag() {
      pieceBag = 'IJLOTSZ'.split('');
      for (let i = pieceBag.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieceBag[i], pieceBag[j]] = [pieceBag[j], pieceBag[i]];
      }
    }
    function randomPiece() {
      if (pieceBag.length === 0) refillBag();
      return pieceBag.pop();
    }

    // Efeito visual de linhas a limpar
    let flashingRows = [];
    let flashUntil = 0;
    const FLASH_DURATION = 180; // ms

    // Utilitários
    function createMatrix(w,h){ const m=[]; while(h--) m.push(new Array(w).fill(0)); return m; }
    function createPiece(t){
      switch(t){
        case 'I': return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
        case 'O': return [[2,2],[2,2]];
        case 'T': return [[0,3,0],[3,3,3],[0,0,0]];
        case 'S': return [[0,4,4],[4,4,0],[0,0,0]];
        case 'Z': return [[5,5,0],[0,5,5],[0,0,0]];
        case 'J': return [[6,0,0],[6,6,6],[0,0,0]];
        case 'L': return [[0,0,7],[7,7,7],[0,0,0]];
      }
    }

    function collide(arena, p){
      if(!p.matrix) return false;
      const m = p.matrix, o = p.pos;
      for(let y=0;y<m.length;y++){
        for(let x=0;x<m[y].length;x++){
          if(m[y][x]!==0){
            const ay=y+o.y, ax=x+o.x;
            if(ay<0 || ay>=arena.length || ax<0 || ax>=arena[0].length) return true;
            if(arena[ay][ax]!==0) return true;
          }
        }
      }
      return false;
    }

    function merge(arena, p){
      p.matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{ if(v!==0) arena[y+p.pos.y][x+p.pos.x] = v; });
      });
    }

    function rotate(matrix, dir){
      for(let y=0;y<matrix.length;y++){
        for(let x=0;x<y;x++){ [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; }
      }
      if(dir>0) matrix.forEach(r=>r.reverse()); else matrix.reverse();
    }

    function drawBlock(ctx, x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, 1, 1);
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 0.05;
      ctx.strokeRect(x, y, 1, 1);
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(x, y, 0.5, 0.08);
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.fillRect(x+0.5, y+0.92, 0.5, 0.08);
    }

    // Player actions
    function playerRotate(dir){
      if(!started||paused||gameOver||!player.matrix) return;
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
          rotate(player.matrix, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }

    function playerDrop(){
      if(!started||paused||gameOver||!player.matrix) return;
      player.pos.y++;
      if(collide(arena,player)){
        player.pos.y--;
        merge(arena,player);
        player.canHold = true;

        if(player.pos.y === 0) { showGameOver(); return; }

        const rows = getFullRows();
        if (rows.length > 0) {
          triggerLineClearEffect(rows);
          const cleared = rows.length;
          player.lines += cleared;
          player.score += cleared * 100;
          checkLevelUp();
          updateScoreboard();
        }

        playerReset();
      }
      dropCounter = 0;
    }

    function playerMove(dir){
      if(!started||paused||gameOver||!player.matrix) return;
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
    }

    function playerHold(){
      if(!started||paused||gameOver||!player.matrix) return;
      if(!player.canHold) return;
      player.canHold = false;
      if (player.hold === null) {
        player.hold = player.matrix;
        player.matrix = player.next;
        player.next = createPiece(randomPiece());
        resetPlayerPosition();
        drawNext();
        if (collide(arena, player)) { showGameOver(); return; }
        return;
      }
      const temp = player.hold;
      player.hold = player.matrix;
      player.matrix = temp;
      resetPlayerPosition();
      if (collide(arena, player)) showGameOver();
    }

    function resetPlayerPosition(){
      if(!player.matrix) return;
      player.pos.y = 0;
      player.pos.x = (arena[0].length/2 | 0) - (player.matrix[0].length/2 | 0);
    }

    function playerReset(){
      if(!started) return;
      if(player.next === null){
        player.next = createPiece(randomPiece());
      }
      player.matrix = player.next;
      resetPlayerPosition();
      player.next = createPiece(randomPiece());
      drawNext();
      if (collide(arena, player)) showGameOver();
    }

    // Linhas
    function getFullRows(){
      const rows = [];
      for (let y = arena.length - 1; y >= 0; --y) {
        let full = true;
        for (let x = 0; x < arena[y].length; ++x) {
          if (arena[y][x] === 0) { full = false; break; }
        }
        if (full) rows.push(y);
      }
      return rows;
    }

    function removeRows(rows){
      rows.sort((a,b)=>a-b);
      for (let i = rows.length - 1; i >= 0; i--) {
        const y = rows[i];
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
      }
    }

    function triggerLineClearEffect(rows){
      // Som
      try { lineClearSound.currentTime = 0; lineClearSound.play(); } catch(e){}

      // Visual
      flashingRows = rows.slice();
      flashUntil = performance.now() + FLASH_DURATION;

      // Após o flash, remove as linhas e limpa estado do efeito
      setTimeout(() => {
        removeRows(rows);
        flashingRows = [];
      }, FLASH_DURATION);
    }

    // Desenho
    function drawMatrix(matrix,offset,colorOverride=null,ctx=context){
      matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v!==0){
            const color = colorOverride ? colorOverride : colors[v];
            drawBlock(ctx, x+offset.x, y+offset.y, color);
          }
        });
      });
    }

    function drawGhost(){
      if(!player.matrix || gameOver) return;
      const ghost = { pos: { x: player.pos.x, y: player.pos.y }, matrix: player.matrix };
      while (!collide(arena, ghost)) ghost.pos.y++;
      ghost.pos.y--;
      drawMatrix(ghost.matrix, ghost.pos, 'rgba(255,255,255,0.2)');
    }

    function draw(){
      context.fillStyle='#000';
      context.fillRect(0,0,canvas.width,canvas.height);

      // Arena com flash nas linhas
      for (let y = 0; y < arena.length; y++) {
        const isFlashing = flashingRows.includes(y) && performance.now() < flashUntil;
        for (let x = 0; x < arena[y].length; x++) {
          const v = arena[y][x];
          if (v !== 0) {
            const color = isFlashing ? '#ffffff' : colors[v];
            drawBlock(context, x, y, color);
          }
        }
      }

      // Peça atual e ghost
      if(player.matrix){
        if(!gameOver) drawGhost();
        drawMatrix(player.matrix, player.pos);
      }
    }

    function drawNext(){
      nextCtx.fillStyle='#000';
      nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
      if(!player.next) return;
      const pieceW=player.next[0].length;
      const pieceH=player.next.length;
      const offsetX=Math.floor((5-pieceW)/2);
      const offsetY=Math.floor((5-pieceH)/2);
      drawMatrix(player.next,{x:offsetX,y:offsetY},null,nextCtx);
    }

    // Loop
    function update(time=0){
      const delta = time - lastTime;
      lastTime = time;
      if (started && !paused && !gameOver) {
        dropCounter += delta;
        if (dropCounter > dropInterval) playerDrop();
      }
      draw();
      requestAnimationFrame(update);
    }

    // Score/level
    function checkLevelUp(){
      const newLevel = Math.floor(player.lines / 10) + 1;
      if (newLevel !== player.level) {
        player.level = newLevel;
        dropInterval = Math.max(1000 - (player.level - 1) * 100, 100);
      }
    }

    function updateScoreboard(){
      const el = document.getElementById('scoreboard');
      if (!el) return;
      el.textContent = 'Score: ' + player.score + ' | Linhas: ' + player.lines + ' | Level: ' + player.level;
    }

    // Game Over
    function showGameOver(){
      gameOver = true;
      paused = true;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'FIM DE JOGO';
      overlayInfo.textContent = 'Score: ' + player.score;
      overlayBtn.textContent = 'Novo Jogo';
      startPauseBtn.textContent = 'Retomar';
      startPauseBtn.classList.remove('start','pause');
      startPauseBtn.classList.add('resume');
    }

    // Reset
    function hardReset(){
      arena.forEach(row => row.fill(0));
      player.score = 0;
      player.lines = 0;
      player.level = 1;
      player.matrix = null;
      player.next = null;
      player.hold = null;
      player.canHold = true;
      player.pos.x = 0; player.pos.y = 0;
      dropCounter = 0; lastTime = 0;
      dropInterval = 1000;
      flashingRows = [];
      flashUntil = 0;
      updateScoreboard();
      nextCtx.fillStyle='#000';
      nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    }

    // Iniciar/Pausar (não atua em Game Over)
    function startPauseToggle(){
      if (gameOver) return;

      // Início pelo overlay "TETRIS"
      if (overlay.style.display === 'flex' && overlayTitle.textContent === 'TETRIS') {
        startFromOverlay();
        return;
      }

      if (!started) {
        started = true;
        paused = false;
        playerReset();
        updateScoreboard();
        startPauseBtn.textContent = 'Pausar';
        startPauseBtn.classList.remove('start','resume');
        startPauseBtn.classList.add('pause');
      } else if (paused) {
        paused = false;
        startPauseBtn.textContent = 'Pausar';
        startPauseBtn.classList.remove('resume');
        startPauseBtn.classList.add('pause');
      } else {
        paused = true;
        startPauseBtn.textContent = 'Retomar';
        startPauseBtn.classList.remove('pause');
        startPauseBtn.classList.add('resume');
      }
    }

    function startFromOverlay(){
      overlay.style.display = 'none';
      overlayTitle.textContent = 'TETRIS';
      overlayInfo.textContent = '';
      overlayBtn.textContent = 'Iniciar';
      started = true;
      paused = false;
      gameOver = false;
      playerReset();
      updateScoreboard();
      startPauseBtn.textContent = 'Pausar';
      startPauseBtn.classList.remove('start','resume');
      startPauseBtn.classList.add('pause');
    }

    function restartGame(){
      overlay.style.display = 'none';
      gameOver = false;
      hardReset();
      started = true;
      paused = false;
      playerReset();
      updateScoreboard();
      startPauseBtn.textContent = 'Pausar';
      startPauseBtn.classList.remove('start','resume');
      startPauseBtn.classList.add('pause');
    }

    // Controles
    document.addEventListener('keydown', e => {
      const keyLower = e.key.toLowerCase();
      if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(keyLower)) e.preventDefault();

      if (keyLower === 'p') { startPauseToggle(); return; }
      if (keyLower === 'r') { restartGame(); return; }

      if (!started || paused || gameOver) return;
      if (e.key === 'ArrowLeft') playerMove(-1);
      else if (e.key === 'ArrowRight') playerMove(1);
      else if (e.key === 'ArrowDown') playerDrop();
      else if (e.key === 'ArrowUp') playerRotate(1);
      else if (e.code === 'Space') {
        while (!collide(arena, player)) player.pos.y++;
        player.pos.y--;
        merge(arena, player);
        player.canHold = true;

        if (player.pos.y === 0) { showGameOver(); return; }

        const rows = getFullRows();
        if (rows.length > 0) {
          triggerLineClearEffect(rows);
          const cleared = rows.length;
          player.lines += cleared;
          player.score += cleared * 100;
          checkLevelUp();
          updateScoreboard();
        }

        playerReset();
        dropCounter = 0;
      } else if (keyLower === 'c') {
        playerHold();
      }
    });

    update();

    // Botões
    startPauseBtn.addEventListener('click', startPauseToggle);
    overlayBtn.addEventListener('click', () => {
      if (overlayTitle.textContent === 'FIM DE JOGO') {
        overlay.style.display = 'none';
        gameOver = false;
        hardReset();
        started = true;
        paused = false;
        playerReset();
        updateScoreboard();
        startPauseBtn.textContent = 'Pausar';
        startPauseBtn.classList.remove('start','resume');
        startPauseBtn.classList.add('pause');
      } else {
        startFromOverlay(); // botão Iniciar do popup
      }
    });
  </script>
</body>
</html>
